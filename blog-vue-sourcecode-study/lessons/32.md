# vuex 的初始化

> import vuex 的初始化：安装与 Store 实例化

## 安装

> 通过 mixin 的方式在组件 beforeCreate 生命周期的时候往组件注册\$store

```js
// src/index.js
import { Store, install } from "./store";
import { mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers } from "./helpers";
export default {
  Store,
  install,
  version: "__VERSION__",
  mapState,
  mapMutations,
  mapGetters,
  mapActions,
  createNamespacedHelpers
};
// src/store.js
// 把传入的_Vue赋给Vue，并执行applyMixin方法
export function install(_Vue) {
  if (Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== "production") {
      console.error("[vuex] already installed. Vue.use(Vuex) should be called only once.");
    }
    return;
  }
  // 把传入的_Vue赋给Vue
  Vue = _Vue;
  // 并执行applyMixin方法
  applyMixin(Vue);
}
// src/mixin.js
// 核心方法：通过mixin的方式在组件beforeCreate生命周期的时候往组件注册$store
export default function (Vue) {
  const version = Number(Vue.version.split('.')[0])
  if (version >= 2) {
    // 2.x版本
    Vue.mixin({ beforeCreate: vuexInit })
  } else {
    // 兼容1.x版本
  }
  function vuexInit () {
    const options = this.$options
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store
    }
  }
}
```

## Store 实例化

> 1. import Vuex from "vuex" 会实例化 Store 对象，并且返回 store 实例，传入 new Vue 的 options 中，并且往 Store 的构造函数传入 actions getters state muations modules
> 2. vuex 为了保证 store 不会随着应用的变大而变得臃肿，提出了模块的概念：`把 store 分隔成 module，每个 module 允许有自己的 state、mutation，action，getter和childmodule，store 本身可以理解成为一个根 module`
> 3. 所以 store 的实例化分为三部分：1、初始化模块：收集 module 的构造函数 2、安装模块 3、初始化 store.\_vm

```js
// src/store.js
// Store的构造函数
export class Store {
  constructor(options = {}) {
    const { plugins = [], strict = false } = options;
    // 初试化依赖的参数
    this._committing = false;
    this._actions = Object.create(null);
    this._actionSubscribers = [];
    this._mutations = Object.create(null);
    this._wrappedGetters = Object.create(null);
    // 一、初始化模块：收集module的构造函数
    this._modules = new ModuleCollection(options);
    this._modulesNamespaceMap = Object.create(null);
    this._subscribers = [];
    this._watcherVM = new Vue();
    // 绑定commit 和 dispatch 信号机制
    const store = this;
    const { dispatch, commit } = this;
    this.dispatch = function boundDispatch(type, payload) {
      return dispatch.call(store, type, payload);
    };
    this.commit = function boundCommit(type, payload, options) {
      return commit.call(store, type, payload, options);
    };
    // 是否开始严格模式
    this.strict = strict;
    const state = this._modules.root.state;
    // 二、安装模块
    installModule(this, state, [], this._modules.root);
    // 三、初始化 store.\_vm
    resetStoreVM(this, state);
    // 导入插件
    plugins.forEach((plugin) => plugin(this));
    if (Vue.config.devtools) {
      devtoolPlugin(this);
    }
  }
}
```

- 初始化模块：收集 module 的构造函数

```js
// 初始化模块：收集module的构造函数
// src/module/module-collection.js
export default class ModuleCollection {
  constructor(rawRootModule) {
    // 一、首先是注册module，传入参数：路径，模块的原始配置，是否在运行的时候创建模块
    this.register([], rawRootModule, false);
  }
  // 根据路径获取到父模块
  get(path) {
    return path.reduce((module, key) => {
      return module.getChild(key);
    }, this.root);
  }

  getNamespace(path) {
    let module = this.root;
    return path.reduce((namespace, key) => {
      module = module.getChild(key);
      return namespace + (module.namespaced ? key + "/" : "");
    }, "");
  }

  update(rawRootModule) {
    update([], this.root, rawRootModule);
  }
  // 注册
  register(path, rawModule, runtime = true) {
    // 1、创建一个Module实例
    const newModule = new Module(rawModule, runtime);
    if (path.length === 0) {
      // 如果store树的长度为0，表明是一个根模块
      this.root = newModule;
    } else {
      // 如果store树的长度不为0，建立module的父子关系：1)根据路径获取到父模块 2)调用addChild建立父子关系
      const parent = this.get(path.slice(0, -1));
      parent.addChild(path[path.length - 1], newModule);
    }
    // 2、遍历当前模块中定义的所有modules，遍历的时候当前索引作为注册module的path，然后递归调用注册
    if (rawModule.modules) {
      forEachValue(rawModule.modules, (rawChildModule, key) => {
        this.register(path.concat(key), rawChildModule, runtime);
      });
    }
  }
  // 卸载module
  unregister(path) {
    const parent = this.get(path.slice(0, -1));
    const key = path[path.length - 1];
    if (!parent.getChild(key).runtime) return;
    parent.removeChild(key);
  }
}
// src/module/module.js
export default class Module {
  constructor (rawModule, runtime) {
    // 是否在运行时候创建
    this.runtime = runtime
    // 所有的子模块，默认是一个空对象
    this._children = Object.create(null)
    // 这个是模块的配置参数
    this._rawModule = rawModule
    const rawState = rawModule.state

    // 当前模块定义的state
    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}
  }
  get namespaced () {
    return !!this._rawModule.namespaced
  }
  addChild (key, module) {
    this._children[key] = module
  }
  removeChild (key) {
    delete this._children[key]
  }
  getChild (key) {
    return this._children[key]
  }
  update (rawModule) {
    this._rawModule.namespaced = rawModule.namespaced
    if (rawModule.actions) {
      this._rawModule.actions = rawModule.actions
    }
    if (rawModule.mutations) {
      this._rawModule.mutations = rawModule.mutations
    }
    if (rawModule.getters) {
      this._rawModule.getters = rawModule.getters
    }
  }
  forEachChild (fn) {
    forEachValue(this._children, fn)
  }
  forEachGetter (fn) {
    if (this._rawModule.getters) {
      forEachValue(this._rawModule.getters, fn)
    }
  }
  forEachAction (fn) {
    if (this._rawModule.actions) {
      forEachValue(this._rawModule.actions, fn)
    }
  }
  forEachMutation (fn) {
    if (this._rawModule.mutations) {
      forEachValue(this._rawModule.mutations, fn)
    }
  }
}
```
