## vue splice 数组，数组里面删除了，但是 dom 中指定位置的数据没有删除

> 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移
> 动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。
> 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性
> 。理想的 key 值是每项都有的唯一 id。

## 通过数组下标给数组添加元素、修改数组长度，对象属性的添加与删除

```txt
针对数组
1、Vue.set(item,index,value)
2、使用数组的 splice，push，pop，unshift，shift 等方法
```

```txt
针对对象
Vue.set(object, key, value)
```

## async 和 await 如何优雅的捕获异常

```js
export function catchError(promise) {
  if (!promise || !Promise.prototype.isPrototypeOf(promise)) {
    return new Promise((resolve, reject) => {
      reject(new Error('requires promises as the param'))
    }).catch(err => {
      return [err, null]
    })
  }
  return promise
    .then(function() {
      return [null, ...arguments]
    })
    .catch(err => {
      return [err, null]
    })
}
```

## vue 如何设置代理

```js
proxyTable: {
  "/api": {
    target: "http://example.com,
    changeOrigin: true,
    pathRewrite: {
      "^/api": ""
    }
  }
}
```

## .vue 中如何使用 background-url

```less
// common是src中定义的文件夹
// common是个alias
background: url(~common/images/icon-tips2.png) no-repeat center / 100%;
```

## vue 中如何优雅的使用 axios

```js
// index.js
import _axios from './axios'
export default {
  getData() {
    return _axios('static/index.json')
  }
}
```

```js
import axios from 'axios'
// 需要使用代理来解决跨域问题
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'
axios.defaults.timeout = 20000

// Add a request interceptor
axios.interceptors.request.use(
  config => {
    return config
  },
  error => {
    return Promise.reject(error)
  }
)
export default async (url = '', params = {}, method = 'get', isUpload = false) => {
  method = method.toLowerCase()
  if (method === 'get') {
    let paramArr = []
    for (let [key, value] of Object.entries(params)) {
      paramArr.push(key + '=' + value)
    }
    if (paramArr.length > 0) {
      url += '?' + paramArr.join('&').replace(/#/g, '%23')
    }
    return new Promise((resolve, reject) => {
      axios
        .get(url)
        .then(
          response => {
            resolve(response.data)
          },
          err => {
            reject(err)
          }
        )
        .catch(error => {
          reject(error)
        })
    })
  } else if (method === 'post') {
    let config = {}
    if (isUpload) {
      config = {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      }
    }
    return new Promise((resolve, reject) => {
      axios
        .post(url, params, config)
        .then(
          response => {
            resolve(response.data)
          },
          err => {
            reject(err)
          }
        )
        .catch(error => {
          reject(error)
        })
    })
  } else if (method === 'put') {
    return new Promise((resolve, reject) => {
      axios
        .put(url, params)
        .then(
          response => {
            resolve(response.data)
          },
          err => {
            reject(err)
          }
        )
        .catch(error => {
          reject(error)
        })
    })
  } else if (method === 'delete') {
    return new Promise((resolve, reject) => {
      axios
        .delete(url)
        .then(
          response => {
            resolve(response.data)
          },
          err => {
            reject(err)
          }
        )
        .catch(error => {
          reject(error)
        })
    })
  } else {
    let error = '传递的参数错误'
    return Promise.reject(error)
  }
}
```

## vue 中属性与事件绑定的一些小技巧

```html
<!-- 绑定字符串不需要加冒号 -->
<Component message="hello" />
<!-- 布尔属性省略值时默认为 true -->
<Component visible="hello" />
<!-- 绑定无参函数事件不用加括号，并且传递了event对象 -->
<button @click="onClick">按钮</button>
```

## Vue 背景图打包之后访问路径错误问题

> 检查 config 文件中的 assetsPublicPath 是否设置为’/’而不是’./

## 父组件如何向子组件动态传值

> 通过 ref 属性，父组件调用子组件的方法，把要传的数组作为参数传给子组件，子组件获取该参数，并使用

> watch 监听并赋值

## 组件销毁之前清除定时器

```js
const timer = setInterval(() => {
  // 某些定时器操作
}, 500)
// 通过$once来监听定时器，在beforeDestroy钩子可以被清除。
this.$once('hook:beforeDestroy', () => {
  clearInterval(timer)
})
```

## less 中的深度选择器

```less
.parent /deep/ .child {
  /* ... */
}
```

## v-el 的使用

```html
<span v-el:msg>hello</span>
```

```js
this.$els.msg //<span>hello</span>
```

## 暴力切断变量引用问题

```js
JSON.parse(JSON.stringify(data))
```

## vue、react 和 angular 的区别

```txt
1.与AngularJS的区别
相同点：
都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。

不同点：
AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。

2.与React的区别
相同点：
React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。
不同点：
React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。
```

## vue 几种常用的指令

> v-for 、 v-if 、v-bind、v-on、v-show、v-else

> 比较偏的还有 v-el
